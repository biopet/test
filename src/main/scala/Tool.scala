import java.io._

import scala.collection.JavaConverters._
import scala.collection.mutable.ListBuffer
import scala.io.Source
object Tool {
  def main(args: Array[String]): Unit = {
    val docsDir: String = args(0)
    Documentation.generatePages(docsDir)
  }

  def generatePages(docsDir: String): Unit = {
    val directory = new File(docsDir)
    directory.mkdir()
    Documentation.generatePages(docsDir)
  }

  class DocPage(fileName: String,
                 text: String

                ) {
    def showFilename: String = fileName
    def generateTextFile(): Unit = {
      val printWriter = new PrintWriter(new File(fileName))
      printWriter.write(text)
      printWriter.close()
      }
    }

  object Documentation {

    def generatePages(docsDir: String): Unit = {
      val title = "Bla manual"
      val readme: DocPage = {
        new DocPage(docsDir + "index.md",
          """
            |# Markdown test
            |
            |This is a very long string.
            |
            |It contains newlines.
            |
            |It is Markdown.
            |
            |It also contains
            |
            |    arbitrary code
            |    Should be indented
            |    Laika does not (yet) support
            |    github flavoured markdown
            |
            |
            |
            |And some more `stuff` like that. Such as:
            |
            |* This
            |* Stuff
            |* ReST is better
            |
            |Paragraph1
            |
            |Paragraph2.
          """.stripMargin('|')
        )
      }
      val manual: DocPage = {
        new DocPage(docsDir + "manual.md",
          """# Manual
            |
            |Some information
            |
            |# Usage
            |
            |Should be autogenerated
            |
            |# Example
            |Should be autogenerated.
            |""".stripMargin
        )
      }
      val docPages: List[DocPage]= List(readme, manual)
      def generateConfig: Unit = {
        val printWriter = new PrintWriter(new File(docsDir + "directory.conf"))
        def navigationOrder: String = {
          val orderList = new ListBuffer[String]
          for (docPage <-docPages) {
            orderList.append(docPage.showFilename)
          }
          orderList mkString("\n")
        }

        val config: String = {
          "title = \"" + title + "\"\n" +
            "navigationOrder = [\n" +
            navigationOrder +
            "\n]"
        }
        printWriter.write(config)
        printWriter.close()
      }

      def resourceToFile(resource: String, output: String): Unit = {
        val outputFile = new File(output)
        outputFile.createNewFile()
        val printWriter = new PrintWriter(outputFile)

        val source = getClass.getResourceAsStream(resource)
        val lines: Iterator[String] = Source.fromInputStream(source).getLines
        lines.foreach(line => printWriter.println(line))
        printWriter.close()
      }
      def generateTemplateHTML: Unit = {
        val outputFile = new File(docsDir + "default.template.html")
        outputFile.createNewFile()
        val printWriter = new PrintWriter(outputFile)

        val htmlSource = getClass.getResourceAsStream("/default.template.html")
        val lines: Iterator[String] = Source.fromInputStream(htmlSource).getLines
        lines.foreach(line => printWriter.println(line))
        printWriter.close()
      }

      val navigationOrder: String = docPages.toString()
      for (docPage <- docPages){
        docPage.generateTextFile()
      }
      generateConfig
      resourceToFile("/default.template.html", docsDir + "default.template.html")
      resourceToFile("/bootstrap.css", docsDir + "bootstrap.css")
      resourceToFile("/docs.css", docsDir + "docs.css")
    }


  }
}
